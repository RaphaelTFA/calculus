1Ô∏è‚É£ OVERVIEW

This system implements a multi-type mathematical interaction engine built on strict primitive ownership and deterministic recomputation.

Each interaction type owns exactly one primitive.

All other values are derived.

No interaction type may leak its primitive or mix with another.

All interactions follow this universal recompute contract:

recompute(interaction, state) 
‚Üí { newState, systemState }

Where:

interaction = immutable lesson JSON

state = minimal primitive state owned by this type

newState = next primitive state

systemState = fully derived geometry + metrics

render() consumes only systemState

render NEVER mutates semantic state

recompute NEVER performs rendering

2Ô∏è‚É£ INTERACTION TYPES
üî∑ TYPE A ‚Äî Resolution Interaction
Primitive Owned:

Resolution / sampling fidelity

State:
state = {
  resolution: number
}
JSON Structure:
{
  interactionType: "A",

  parameterSpec: {
    resolution: {
      min: 10,
      max: 200,
      step: 1
    }
  },

  systemSpec: {
    functionRule: {
      type: "expression",
      expression: "sin(x)",
      variables: ["x"]
    },
    domain: {
      xMin: -5,
      xMax: 5
    }
  },

  representationSpec: {
    encoding: "curve",
    viewBox: {
      xMin: -5,
      xMax: 5,
      yMin: -2,
      yMax: 2
    }
  }
}
Semantics:

Resolution changes sampling density only.
Function definition NEVER changes.
Domain NEVER changes.
No semantic parameters.

üî∑ TYPE B ‚Äî Parameter Control Interaction
Primitive Owned:

Semantic parameter

State:
state = {
  parameterValue: number
}
JSON Structure:
{
  interactionType: "B",

  parameterSpec: {
    parameter: {
      name: "a",
      min: -5,
      max: 5,
      step: 0.1,
      initial: 1
    }
  },

  systemSpec: {
    functionRule: {
      type: "expression",
      expression: "a * x^2",
      variables: ["x","a"]
    },
    domain: {
      xMin: -5,
      xMax: 5
    }
  },

  representationSpec: {
    encoding: "curve",
    viewBox: {
      xMin: -5,
      xMax: 5,
      yMin: -10,
      yMax: 10
    }
  }
}
Semantics:

Parameter modifies semantic function.
Sampling fidelity is fixed.
No time primitive.
No structural reordering.

üî∑ TYPE C ‚Äî Temporal Playback
Primitive Owned:

Time

State:
state = {
  t: number
}
JSON Structure:
{
  interactionType: "C",

  parameterSpec: {
    time: {
      start: 0,
      end: 6.28318,
      step: 0.02
    }
  },

  systemSpec: {
    initialState: {
      x: 0,
      y: -1
    },
    evolutionRule: {
      type: "expression",
      expression: "[cos(t), sin(t)]",
      variables: ["t","x","y"]
    }
  },

  representationSpec: {
    encoding: "motion",
    viewBox: {
      xMin: -1.2,
      xMax: 1.2,
      yMin: -1.2,
      yMax: 1.2
    }
  },

  reflectionSpec: {
    triggers: [
      {
        type: "timeReached",
        value: 3.14159,
        message: "Half cycle reached."
      }
    ]
  }
}
Critical Architecture Rules:

recompute must perform deterministic replay from start ‚Üí state.t

No incremental mutation

Position, trace, energy must be derived each frame

render must never compute physics

Only time changes

üî∑ TYPE E ‚Äî Structural Decomposition Interaction
Primitive Owned:

Structural parameter

Represents a normalized structural selector in 
0
,
1
0,1.

This parameter modifies how a conserved geometric quantity is partitioned or emphasized.

State
state = {
  structure: number
}
JSON Structure
{
  "interactionType": "E",

  "parameterSpec": {
    "structure": {
      "min": 0,
      "max": 1,
      "step": 0.01,
      "initial": 0.5
    }
  },

  "systemSpec": {
    "baseValues": {...},

    "conservedObject": {
      "type": "expression",
      "expression": "...",
      "variables": [...]
    }
  },

  "representationSpec": {
    "mode": "geometricSplit",

    "geometryBase": {
      "type": "rectangle | areaUnderCurve | regionBetweenCurves"
    },

    "splitSpec": {
      "type": "rectangleContribution | domainSplit | signPartition"
    },

    "viewBox": {...}
  },

  "reflectionSpec": {...}
}
Semantics

‚Ä¢ structure modifies partitioning or emphasis only
‚Ä¢ conservedObject NEVER changes
‚Ä¢ geometryBase NEVER changes
‚Ä¢ splitSpec derives partitions deterministically
‚Ä¢ invariant must be validated after recompute
‚Ä¢ No semantic parameter
‚Ä¢ No time
‚Ä¢ No resolution control

Structural Meaning by splitSpec

rectangleContribution ‚Üí contribution emphasis

domainSplit ‚Üí boundary position

signPartition ‚Üí interval selection

Determinism Rule

All partitions must be derived from geometryBase and structure.

No partition may be stored in state.

render consumes derived partitions only.

3Ô∏è‚É£ UNIVERSAL ENGINE CONTRACT

Every interaction must obey:

function recompute(interaction, state) {
  return {
    newState: minimalPrimitiveState,
    systemState: {
      geometry: [...],
      metrics: {...},
      invariants: {...}
    }
  }
}

Rules:

‚Ä¢ recompute is pure
‚Ä¢ render consumes systemState only
‚Ä¢ No physics in render
‚Ä¢ No geometry in React state
‚Ä¢ No mutation of interaction JSON
‚Ä¢ All DSL expressions evaluated through createEvaluator

4Ô∏è‚É£ DSL EVALUATOR CONTRACT

All expression rules use:

{
  type: "expression",
  expression: "...",
  variables: [...]
}

Allowed functions:

sin

cos

abs

sqrt

pow

log

exp

sign

Expressions may return:

scalar

vector (Type C)

arithmetic sum (Type E)

5Ô∏è‚É£ ADAPTATION REQUIREMENTS FOR NEW SYSTEM

When adapting into a new process, the agent must:

Map interactionType to correct primitive owner

Preserve recompute purity

Preserve deterministic replay for Type C

Preserve structural-only mutation for Type E

Preserve DSL evaluation boundaries

Avoid mixing primitives

Avoid converting derived values into stored state

Avoid converting layout algorithms into semantic rules

6Ô∏è‚É£ ABSOLUTE PROHIBITIONS

The adapting agent must NOT:

Merge types

Introduce new primitives

Convert deterministic replay into incremental mutation

Store geometry in persistent state

Let rendering compute semantic values

Convert conservation into hardcoded sums

Hardcode layout per lesson

Replace DSL with eval without scoping

7Ô∏è‚É£ WHAT IS ENGINE CAPABILITY VS LESSON SEMANTICS

Engine Capabilities:

layoutTemplates

encoding modes

trace rendering

axes rendering

DSL evaluator

animation loop

drag-to-reorder

Lesson Semantics:

expression strings

parameter ranges

conservation formulas

initial conditions

reflection triggers

Engine may interpret capabilities.
Engine may NOT reinterpret semantics.

8Ô∏è‚É£ FINAL GOAL FOR ADAPTATION AGENT

The adapted implementation must:

Produce identical visual output

Preserve invariant behavior

Preserve primitive ownership

Preserve JSON-driven configuration

Maintain separation of:

semantic definition

state transition

rendering